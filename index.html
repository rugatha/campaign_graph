<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rugatha Campaign Graph</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body {
      margin: 0;
      background: #0b0d11;
      color: #e5e7eb;
      font-family: system-ui, sans-serif;
    }

    h1 {
      text-align: center;
      margin: 16px 0 8px;
      font-size: 20px;
      font-weight: 600;
      color: #f9fafb;
    }

    #rugatha-graph-plugin {
      width: 100%;
      height: calc(100vh - 60px);
    }

    #rugatha-graph-svg {
      width: 100%;
      height: 100%;
      background: #05070a;
      cursor: grab;
      user-select: none;
    }

    .rugatha-edge {
      stroke: #374151;
      stroke-width: 1.3;
      stroke-opacity: 0.7;
    }

    .node-rect {
      stroke: #111827;
      stroke-width: 1.4;
    }
    .level-2 .node-rect { fill: #3b82f6; }
    .level-3 .node-rect { fill: #9ca3af; }

    .node-label {
      fill: #f9fafb;
      pointer-events: none;
      text-anchor: middle;
      dominant-baseline: central;
    }
    .level-1 .node-label { font-size: 14px; font-weight: 800; }
    .level-2 .node-label { font-size: 12px; font-weight: 700; }
    .level-3 .node-label { font-size: 10px; font-weight: 500; }
  </style>
</head>

<body>
<h1>Rugatha Campaign Graph</h1>

<div id="rugatha-graph-plugin">
  <svg id="rugatha-graph-svg"></svg>
</div>

<script src="graph-data.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>

<script>
(function () {

const ROOT_ICON_URL =
  "https://rugatha.wordpress.com/wp-content/uploads/2025/05/cropped-e69caae591bde5908d-1_e5b7a5e4bd9ce58d80e59f9f-1-1.png";

const rawData = window.CAMPAIGN_GRAPH_DATA || [];

function init() {
  const svg = d3.select("#rugatha-graph-svg");
  const width = svg.node().clientWidth;
  const height = svg.node().clientHeight;

  const viewport = svg.append("g").attr("id", "v");

  // Build node map
  const nodeById = new Map();
  rawData.forEach(d => {
    nodeById.set(d.id, {
      id: d.id,
      label: d.label,
      level: d.level,
      parent: d.parent,
      children: [],
      expanded: d.level === 1,
      visible: false,
      x: width / 2,
      y: height / 2
    });
  });

  nodeById.forEach(n => {
    if (n.parent) nodeById.get(n.parent).children.push(n);
  });

  function computeVisibility() {
    nodeById.forEach(n => (n.visible = false));
    nodeById.forEach(n => { if (!n.parent) n.visible = true; });

    let changed = true;
    while (changed) {
      changed = false;
      nodeById.forEach(n => {
        if (!n.parent) return;
        const p = nodeById.get(n.parent);
        if (p.visible && p.expanded && !n.visible) {
          n.visible = true; changed = true;
        }
      });
    }
  }

  // Rounded rectangle size
  function getRectSize(n) {
    const t = n.label.length;
    let baseW, baseH, perChar;
    if (n.level === 1) { baseW = 180; baseH = 60; perChar = 5; }
    else if (n.level === 2) { baseW = 170; baseH = 50; perChar = 4.5; }
    else { baseW = 160; baseH = 44; perChar = 4; }

    const w = Math.max(baseW, 40 + t * perChar);
    return { width: w, height: baseH };
  }

  // Child radial placement (clockwise)
  function placeChildrenClockwise(parent, children) {
    const step = (2 * Math.PI) / children.length;
    const radius = parent.level === 1 ? 260 : 210;  // 層級越高，外圈越遠

    children.forEach((c, i) => {
      const a = 0 - i * step; // 順時針
      c.fx = parent.x + Math.cos(a) * radius;
      c.fy = parent.y + Math.sin(a) * radius;
    });
  }

  function buildGraphData() {
    computeVisibility();
    const nodes = [];
    const links = [];

    nodeById.forEach(n => { if (n.visible) nodes.push(n); });
    nodeById.forEach(n => {
      if (n.visible && n.parent) {
        links.push({ source: nodeById.get(n.parent), target: n });
      }
    });

    // apply radial placement
    nodes.forEach(n => {
      if (n.expanded && n.children.length > 0) {
        const visibleKids = n.children.filter(c => c.visible);
        placeChildrenClockwise(n, visibleKids);
      }
    });

    return { nodes, links };
  }

  let { nodes, links } = buildGraphData();

    const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links)
      .id(d => d.id)
      .distance(160)
      .strength(0.3))
    .force("charge", d3.forceManyBody().strength(-400))
    .force("collide", d3.forceCollide().radius(d => getRectSize(d).width / 2 + 20))
    .force("x", d3.forceX(d => d.parent ? (d.parent * 3) : 0).strength(0.05))
    .force("y", d3.forceY(height / 2).strength(0.02))
    .alphaTarget(0.15)  <!-- 動畫速度下降一半 -->
    .on("tick", ticked);

  let linkSel = viewport.append("g").selectAll("line");
  let nodeSel = viewport.append("g").selectAll("g");

  function updateGraph() {
    ({ nodes, links } = buildGraphData());
    simulation.nodes(nodes);
    simulation.force("link").links(links);
    simulation.alpha(0.5).restart();  <!-- 平滑動畫模式 -->

    linkSel = linkSel.data(links, d => d.source.id + "-" + d.target.id);
    linkSel.exit().remove();
    linkSel = linkSel.enter().append("line")
      .attr("class", "rugatha-edge")
      .merge(linkSel);

    nodeSel = nodeSel.data(nodes, d => d.id);
    nodeSel.exit().remove();

    const enter = nodeSel.enter()
      .append("g")
      .attr("class", d => "level-" + d.level)
      .call(d3.drag()
        .on("start", dragstart)
        .on("drag", dragmove)
        .on("end", dragend));

    // Root icon
    enter.each(function(d) {
      const g = d3.select(this);
      if (d.level === 1) {
        const size = 90;
        g.append("image")
          .attr("href", ROOT_ICON_URL)
          .attr("width", size)
          .attr("height", size)
          .attr("x", -size/2)
          .attr("y", -size/2);
      } else {
        const r = getRectSize(d);
        g.append("rect")
          .attr("class", "node-rect")
          .attr("x", -r.width/2)
          .attr("y", -r.height/2)
          .attr("width", r.width)
          .attr("height", r.height)
          .attr("rx", 18).attr("ry", 18);
      }
    });

    enter.append("text")
      .attr("class", "node-label")
      .text(d => (d.level === 1 ? "" : d.label));

    enter.on("click", (event, d) => {
      event.stopPropagation();
      if (d.children.length > 0) d.expanded = !d.expanded;
      updateGraph();
      center(d);
    });

    nodeSel = enter.merge(nodeSel);
  }

  function ticked() {
    linkSel
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    nodeSel.attr("transform", d => `translate(${d.x},${d.y})`);
  }

  function dragstart(event, d) {
    if (!event.active) simulation.alphaTarget(0.15).restart();
    d.fx = d.x; d.fy = d.y;
  }

  function dragmove(event, d) {
    d.fx = event.x; d.fy = event.y;
  }

  function dragend(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null; d.fy = null;
  }

  const zoom = d3.zoom().scaleExtent([0.3, 3])
    .on("zoom", e => viewport.attr("transform", e.transform));

  svg.call(zoom);

  function center(n) {
    const t = d3.zoomIdentity
      .translate(width/2 - n.x, height/2 - n.y)
      .scale(1);

    svg.transition().duration(700).call(zoom.transform, t);
  }

  svg.on("click", () => center({x:0, y:0}));
  updateGraph();
}

if (document.readyState === "loading")
  document.addEventListener("DOMContentLoaded", init);
else init();

})();
</script>

</body>
</html>
