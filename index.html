<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rugatha Campaign Graph (Neo4j style)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body {
      margin: 0;
      background: #0b0d11;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    h1 {
      text-align: center;
      margin: 16px 0 8px;
      font-size: 20px;
      font-weight: 600;
      color: #f9fafb;
    }

    #rugatha-graph-plugin {
      width: 100%;
      height: calc(100vh - 60px);
      max-height: 700px;
      box-sizing: border-box;
    }

    #rugatha-graph-svg {
      width: 100%;
      height: 100%;
      background: #05070a; /* Neo4j-style dark background */
      cursor: grab;
      user-select: none;
    }

    #rugatha-graph-svg.rugatha-panning {
      cursor: grabbing;
    }

    /* edges */
    .rugatha-edge {
      stroke: #374151;
      stroke-width: 1.2;
      stroke-opacity: 0.8;
    }

    /* nodes */
    .rugatha-node circle {
      stroke: #111827;
      stroke-width: 1.2;
    }

    .rugatha-node.level-1 circle {
      r: 26;
      fill: #10b981; /* teal */
    }

    .rugatha-node.level-2 circle {
      r: 22;
      fill: #3b82f6; /* blue */
    }

    .rugatha-node.level-3 circle {
      r: 18;
      fill: #9ca3af; /* gray */
    }

    .rugatha-node text {
      fill: #f9fafb;
      font-size: 10px;
      pointer-events: none;
      text-anchor: middle;
      dominant-baseline: middle;
    }

    .rugatha-node.level-1 text {
      font-size: 12px;
      font-weight: 700;
    }

    .rugatha-node.level-2 text {
      font-size: 11px;
      font-weight: 600;
    }

    .rugatha-node.level-3 text {
      font-size: 10px;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <h1>Rugatha Campaign Graph</h1>

  <div id="rugatha-graph-plugin">
    <svg id="rugatha-graph-svg"></svg>
  </div>

  <!-- 1) campaign hierarchy data -->
  <script src="graph-data.js"></script>

  <!-- 2) D3.js from CDN -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- 3) main script: force-directed Neo4j-style graph -->
  <script>
    (function () {
      const rawData = (window.CAMPAIGN_GRAPH_DATA || []);

      function init() {
        const svg = d3.select("#rugatha-graph-svg");
        if (svg.empty()) return;

        const width = svg.node().clientWidth;
        const height = svg.node().clientHeight;

        // zoom / pan group
        const viewport = svg.append("g").attr("id", "rugatha-graph-viewport");

        // build node map (one object per id)
        const nodeById = new Map();
        rawData.forEach(d => {
          nodeById.set(d.id, {
            id: d.id,
            label: d.label,
            level: d.level,
            parent: d.parent,
            children: [],
            expanded: d.level === 1, // root expanded by default
            visible: false,
            x: width / 2,
            y: height / 2
          });
        });

        // build children list
        nodeById.forEach(node => {
          if (node.parent) {
            const parent = nodeById.get(node.parent);
            if (parent) parent.children.push(node);
          }
        });

        // compute visibility based on expanded ancestors
        function computeVisibility() {
          nodeById.forEach(n => (n.visible = false));
          // find roots (no parent)
          nodeById.forEach(node => {
            if (!node.parent) {
              node.visible = true;
            }
          });

          // BFS from each visible node
          let changed = true;
          while (changed) {
            changed = false;
            nodeById.forEach(node => {
              if (!node.parent) return;
              const parent = nodeById.get(node.parent);
              const shouldBeVisible =
                parent && parent.visible && parent.expanded;
              if (shouldBeVisible && !node.visible) {
                node.visible = true;
                changed = true;
              }
            });
          }
        }

        function buildGraphData() {
          computeVisibility();

          const nodes = [];
          const links = [];

          nodeById.forEach(node => {
            if (node.visible) nodes.push(node);
          });

          nodeById.forEach(node => {
            if (!node.visible || !node.parent) return;
            const parent = nodeById.get(node.parent);
            if (parent && parent.visible) {
              links.push({ source: parent, target: node });
            }
          });

          return { nodes, links };
        }

        let { nodes, links } = buildGraphData();

        /* ---- D3 force simulation ---- */
        const simulation = d3
          .forceSimulation(nodes)
          .force(
            "link",
            d3
              .forceLink(links)
              .id(d => d.id)
              .distance(120)
              .strength(0.9)
          )
          .force(
            "charge",
            d3.forceManyBody().strength(-350)
          )
          .force(
            "center",
            d3.forceCenter(width / 2, height / 2)
          )
          .force("collision", d3.forceCollide().radius(d => {
            if (d.level === 1) return 36;
            if (d.level === 2) return 32;
            return 28;
          }));

        // edges
        let linkSel = viewport
          .append("g")
          .attr("class", "edges")
          .selectAll("line");

        // nodes (group: circle + text)
        let nodeSel = viewport
          .append("g")
          .attr("class", "nodes")
          .selectAll("g");

        function updateGraph() {
          ({ nodes, links } = buildGraphData());

          simulation.nodes(nodes);
          simulation.force("link").links(links);

          // join edges
          linkSel = linkSel
            .data(links, d => d.source.id + "-" + d.target.id);

          linkSel.exit().remove();

          const linkEnter = linkSel
            .enter()
            .append("line")
            .attr("class", "rugatha-edge");

          linkSel = linkEnter.merge(linkSel);

          // join nodes
          nodeSel = nodeSel.data(nodes, d => d.id);

          nodeSel.exit().remove();

          const nodeEnter = nodeSel
            .enter()
            .append("g")
            .attr("class", d => "rugatha-node level-" + d.level)
            .call(
              d3
                .drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)
            );

          nodeEnter
            .append("circle");

          nodeEnter
            .append("text")
            .text(d => d.label);

          nodeEnter.on("click", (event, d) => {
            event.stopPropagation();
            if (d.children && d.children.length > 0) {
              d.expanded = !d.expanded;
              updateGraph();
            }
            centerOnNode(d);
          });

          nodeSel = nodeEnter.merge(nodeSel);

          simulation.alpha(1).restart();
        }

        simulation.on("tick", () => {
          linkSel
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

          nodeSel.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // drag handlers
        function dragstarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }

        function dragged(event, d) {
          d.fx = event.x;
          d.fy = event.y;
        }

        function dragended(event, d) {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = event.x;
          d.fy = event.y;
        }

        // zoom / pan
        const zoom = d3.zoom()
          .scaleExtent([0.3, 3])
          .on("zoom", (event) => {
            viewport.attr("transform", event.transform);
          });

        svg.call(zoom);

        // center viewport on a node
        function centerOnNode(node) {
          const t = d3.zoomIdentity
            .translate(width / 2 - node.x, height / 2 - node.y)
            .scale(1);

          svg.transition()
            .duration(400)
            .call(zoom.transform, t);
        }

        // background click: just recentre all
        svg.on("click", () => {
          const t = d3.zoomIdentity.translate(width / 2, height / 2).scale(1);
          svg.transition().duration(400).call(zoom.transform, t);
        });

        // initial render
        updateGraph();
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
