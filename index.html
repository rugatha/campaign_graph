<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rugatha Campaign Graph</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    /* ====== Outer container ====== */
    #rugatha-graph-plugin {
      width: 100%;
      max-width: 1000px;
      height: 600px;
      margin: 0 auto;
      box-sizing: border-box;
    }

    /* ====== SVG canvas ====== */
    #rugatha-graph-svg {
      width: 100%;
      height: 100%;
      background: #ffffff; /* white background */
      border: 1px solid #ccc;
      cursor: grab;
      user-select: none;
    }

    #rugatha-graph-svg.rugatha-panning {
      cursor: grabbing;
    }

    /* ====== Nodes (ellipses) ====== */
    .rugatha-node ellipse {
      fill: #ffffff;   /* white fill */
      stroke: #000000; /* black stroke */
      stroke-width: 1.5;
    }

    /* ====== Node labels ====== */
    .rugatha-node text {
      fill: #000000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    /* ====== Font sizes by level ====== */
    .rugatha-node.level-1 text {
      font-size: 20px;
      font-weight: bold;
    }

    .rugatha-node.level-2 text {
      font-size: 16px;
      font-weight: 600;
    }

    .rugatha-node.level-3 text {
      font-size: 14px;
      font-weight: 500;
    }

    /* ====== Edges ====== */
    .rugatha-edge {
      stroke: #555555;
      stroke-width: 1.2;
    }
  </style>
</head>
<body>
  <h1 style="text-align:center; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">
    Rugatha Campaign Graph
  </h1>

  <!-- Container + SVG canvas -->
  <div id="rugatha-graph-plugin">
    <svg id="rugatha-graph-svg"></svg>
  </div>

  <!-- 先載入階層資料 -->
  <script src="graph-data.js"></script>

  <!-- 再載入主程式，使用上面的資料 -->
  <script>
    (function () {
      function initRugathaGraph() {
        const svg = document.getElementById("rugatha-graph-svg");
        if (!svg) return;

        const SVG_NS = "http://www.w3.org/2000/svg";

        /* ====== Viewport group: everything (nodes + edges) goes inside here ====== */
        const viewport = document.createElementNS(SVG_NS, "g");
        viewport.setAttribute("id", "rugatha-graph-viewport");
        svg.appendChild(viewport);

        /* ====== Use data from graph-data.js ====== */
        const nodesData = (window.CAMPAIGN_GRAPH_DATA || []).map(function (d) {
          // 確保欄位名稱一致：用 parent → parentId
          return {
            id: d.id,
            label: d.label,
            level: d.level,
            parent: d.parent
          };
        });

        const nodes = [];
        const nodeMap = new Map();
        const edges = [];

        /* ====== View state (pan, zoom) ====== */
        let translate = { x: 120, y: 80 };
        let scale = 1;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        /* ====== Node sizes per level ====== */
        function getSizeForLevel(level) {
          if (level === 1) return { w: 200, h: 70 };
          if (level === 2) return { w: 180, h: 60 };
          return { w: 100, h: 40 }; // level 3
        }

        /* ====== Initialize node objects ====== */
        nodesData.forEach(function (data) {
          const size = getSizeForLevel(data.level);
          const node = {
            id: data.id,
            label: data.label,
            level: data.level,
            parentId: data.parent,
            children: [],
            expanded: data.level === 1, // root expanded by default
            visible: false,
            x: 0,
            y: 0,
            width: size.w,
            height: size.h,
            group: null
          };
          nodeMap.set(node.id, node);
          nodes.push(node);
        });

        // Build parent → children links
        nodes.forEach(function (node) {
          if (!node.parentId) return;
          const parent = nodeMap.get(node.parentId);
          if (parent) parent.children.push(node);
        });

        /* ====== Create SVG nodes: <g> + <ellipse> + <text> ====== */
        nodes.forEach(function (node) {
          const g = document.createElementNS(SVG_NS, "g");
          g.classList.add("rugatha-node", "level-" + node.level);

          const ellipse = document.createElementNS(SVG_NS, "ellipse");
          ellipse.setAttribute("cx", 0);
          ellipse.setAttribute("cy", 0);
          ellipse.setAttribute("rx", node.width / 2);
          ellipse.setAttribute("ry", node.height / 2);

          const text = document.createElementNS(SVG_NS, "text");
          text.setAttribute("x", 0);
          text.setAttribute("y", 0);
          text.textContent = node.label;

          g.appendChild(ellipse);
          g.appendChild(text);

          // Click: toggle children (if any) and center on node
          g.addEventListener("click", function (evt) {
            evt.stopPropagation();
            if (node.children && node.children.length > 0) {
              node.expanded = !node.expanded;
              layoutAndRender();
            }
            centerOnNode(node);
          });

          // Prevent panning start when clicking on a node
          g.addEventListener("mousedown", function (evt) {
            evt.stopPropagation();
          });

          viewport.appendChild(g);
          node.group = g;
        });

        /* ====== Create edges (parent → child) ====== */
        nodes.forEach(function (node) {
          if (!node.parentId) return;
          const parent = nodeMap.get(node.parentId);
          if (!parent) return;
          const line = document.createElementNS(SVG_NS, "line");
          line.classList.add("rugatha-edge");
          viewport.insertBefore(line, viewport.firstChild);
          edges.push({ parent: parent, child: node, line: line });
        });

        /* ====== Apply pan/zoom transform ====== */
        function applyTransform() {
          viewport.setAttribute(
            "transform",
            "translate(" + translate.x + "," + translate.y + ") scale(" + scale + ")"
          );
        }

        /* ====== Center a node in the viewport ====== */
        function centerOnNode(node) {
          if (!node) return;
          const rect = svg.getBoundingClientRect();
          const svgWidth = rect.width;
          const svgHeight = rect.height;

          translate.x = svgWidth / 2 - scale * node.x;
          translate.y = svgHeight / 2 - scale * node.y;
          applyTransform();
        }

        /* ====== Layout and render ====== */
        function layoutAndRender() {
          // 1) Visibility: visible only if all ancestors are expanded
          nodes.forEach(function (node) {
            if (node.level === 1) {
              node.visible = true;
            } else {
              const parent = nodeMap.get(node.parentId);
              node.visible = parent && parent.visible && parent.expanded;
            }
          });

          // 2) Layout: left-to-right by level; level 3 centered around its parent vertically
          const levelX = { 1: 80, 2: 320, 3: 600 };
          const levelStartY = 40;
          const parentGapY = 100;
          const childGapY = 40;

          const levelCounters = { 1: 0, 2: 0 };

          // (a) place level 1 & 2
          nodes.forEach(function (node) {
            if (!node.group) return;

            if (!node.visible) {
              node.group.style.display = "none";
              return;
            }

            if (node.level === 3) return;

            const lvl = node.level;
            const idx = levelCounters[lvl]++;
            node.x = levelX[lvl];
            node.y = levelStartY + idx * parentGapY;

            node.group.style.display = "block";
            node.group.setAttribute(
              "transform",
              "translate(" + node.x + "," + node.y + ")"
            );
          });

          // (b) place level 3 around parent vertically
          const childrenByParent = new Map();
          nodes.forEach(function (node) {
            if (node.level !== 3 || !node.visible) return;
            const parentId = node.parentId;
            if (!childrenByParent.has(parentId)) {
              childrenByParent.set(parentId, []);
            }
            childrenByParent.get(parentId).push(node);
          });

          childrenByParent.forEach(function (children, parentId) {
            const parent = nodeMap.get(parentId);
            if (!parent) return;
            const n = children.length;
            if (n === 0) return;

            children.forEach(function (child, i) {
              const offsetIndex = i - (n - 1) / 2; // centered around parent
              child.x = levelX[3];
              child.y = parent.y + offsetIndex * childGapY;

              child.group.style.display = "block";
              child.group.setAttribute(
                "transform",
                "translate(" + child.x + "," + child.y + ")"
              );
            });
          });

          // (c) update edges
          edges.forEach(function (edge) {
            const parent = edge.parent;
            const child = edge.child;
            if (parent.visible && child.visible) {
              edge.line.style.display = "block";
              edge.line.setAttribute("x1", parent.x);
              edge.line.setAttribute("y1", parent.y);
              edge.line.setAttribute("x2", child.x);
              edge.line.setAttribute("y2", child.y);
            } else {
              edge.line.style.display = "none";
            }
          });
        }

        /* ====== Panning (dragging background) ====== */
        svg.addEventListener("mousedown", function (evt) {
          isPanning = true;
          panStart.x = evt.clientX;
          panStart.y = evt.clientY;
          svg.classList.add("rugatha-panning");
        });

        window.addEventListener("mousemove", function (evt) {
          if (!isPanning) return;
          const dx = evt.clientX - panStart.x;
          const dy = evt.clientY - panStart.y;
          panStart.x = evt.clientX;
          panStart.y = evt.clientY;

          translate.x += dx;
          translate.y += dy;
          applyTransform();
        });

        window.addEventListener("mouseup", function () {
          isPanning = false;
          svg.classList.remove("rugatha-panning");
        });

        /* ====== Mouse wheel zoom ====== */
        svg.addEventListener(
          "wheel",
          function (evt) {
            evt.preventDefault();
            const delta = evt.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * delta;
            if (newScale < 0.3 || newScale > 3) return;
            scale = newScale;
            applyTransform();
          },
          { passive: false }
        );

        // Initial layout
        layoutAndRender();
        applyTransform();
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initRugathaGraph);
      } else {
        initRugathaGraph();
      }
    })();
  </script>
</body>
</html>
