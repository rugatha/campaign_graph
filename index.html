<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rugatha Campaign Graph</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body {
      margin: 0;
      background: #445f56; /* ä¸»åº•è‰² */
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    h1 {
      text-align: center;
      margin: 16px 0 8px;
      font-size: 20px;
      font-weight: 600;
      color: #f9fafb;
    }

    #rugatha-graph-plugin {
      position: relative;
      width: 100%;
      height: calc(100vh - 60px);
      max-height: 700px;
      box-sizing: border-box;
    }

    #rugatha-graph-svg {
      width: 100%;
      height: 100%;
      background: #445f56;
      cursor: grab;
      user-select: none;
    }

    #rugatha-graph-svg.rugatha-panning {
      cursor: grabbing;
    }

    /* é—œè¯ç·š */
    .rugatha-edge {
      stroke: #e4efe9;
      stroke-width: 1.4;
      stroke-opacity: 0.85;
    }

    /* ç¯€é»åœ“è§’çŸ©å½¢ï¼ˆå°ºå¯¸ç”± JS æ§åˆ¶ï¼‰ */
    .node-rect {
      stroke: #203028;
      stroke-width: 1.4;
    }

    .level-2 .node-rect {
      fill: #c6dfd2; /* æŸ”å’Œç¶ ç° */
    }

    .level-3 .node-rect {
      fill: #f4efe5; /* å¥¶æ²¹ç™½ */
    }

    /* ç¯€é»æ–‡å­— */
    .node-label {
      pointer-events: none;
      text-anchor: middle;
      dominant-baseline: central;
    }

    .level-1 .node-label {
      font-size: 14px;
      font-weight: 800;
      fill: #f9fafb;
    }

    .level-2 .node-label {
      font-size: 12px;
      font-weight: 700;
      fill: #203028;
    }

    .level-3 .node-label {
      font-size: 10px;
      font-weight: 500;
      fill: #3b3a34;
    }

    /* å³ä¸Šè§’è¦–åœ–æ§åˆ¶æŒ‰éˆ• */
    #graph-controls {
      position: fixed;
      top: 80px;
      right: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 20;
    }

    .graph-btn {
      width: 36px;
      height: 36px;
      border-radius: 999px;
      border: none;
      background: #f4efe5;
      color: #203028;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.25);
      padding: 0;
    }

    .graph-btn:hover {
      background: #e4dccc;
    }
  </style>
</head>
<body>
  <h1>Rugatha Campaign Graph</h1>

  <div id="rugatha-graph-plugin">
    <svg id="rugatha-graph-svg"></svg>
  </div>

  <!-- è¦–åœ–æ§åˆ¶ icon -->
  <div id="graph-controls">
    <button id="btn-zoom-in"  class="graph-btn" title="æ”¾å¤§æª¢è¦–">+</button>
    <button id="btn-zoom-out" class="graph-btn" title="ç¸®å°æª¢è¦–">âˆ’</button>
    <button id="btn-fit"      class="graph-btn" title="é¡¯ç¤ºå…¨éƒ¨">ğŸ”</button>
    <button id="btn-home"     class="graph-btn" title="å›åˆ°åˆå§‹è¦–åœ–">ğŸ </button>
  </div>

  <!-- éšå±¤è³‡æ–™ -->
  <script src="graph-data.js"></script>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <script>
    (function () {
      const ROOT_ICON_URL =
        "https://rugatha.wordpress.com/wp-content/uploads/2025/05/cropped-e69caae591bde5908d-1_e5b7a5e4bd9ce58d80e59f9f-1-1.png";

      const rawData = window.CAMPAIGN_GRAPH_DATA || [];
      let pendingCenter = null;         // ä¸‹ä¸€æ¬¡ tick è¦ç½®ä¸­çš„ç¯€é»
      let currentTransform = d3.zoomIdentity; // ç›®å‰çš„ zoom transformï¼ˆçµ¦æŒ‰éˆ•ç”¨ï¼‰
      let nodes = [];
      let links = [];

      function init() {
        const svg = d3.select("#rugatha-graph-svg");
        if (svg.empty()) return;

        const width = svg.node().clientWidth;
        const height = svg.node().clientHeight;

        const viewport = svg.append("g").attr("id", "rugatha-viewport");

        // å»ºç«‹ node map
        const nodeById = new Map();
        rawData.forEach(d => {
          nodeById.set(d.id, {
            id: d.id,
            label: d.label,
            level: d.level,
            parent: d.parent,
            children: [],
            expanded: d.level === 1, // root é è¨­å±•é–‹
            visible: false,
            x: width / 2,
            y: height / 2,
            fx: null,
            fy: null
          });
        });

        // parent â†’ children
        nodeById.forEach(n => {
          if (n.parent && nodeById.has(n.parent)) {
            nodeById.get(n.parent).children.push(n);
          }
        });

        // æ ¹æ“š expanded æ±ºå®š visible
        function computeVisibility() {
          nodeById.forEach(n => (n.visible = false));
          // root å¯è¦‹
          nodeById.forEach(n => {
            if (!n.parent) n.visible = true;
          });

          let changed = true;
          while (changed) {
            changed = false;
            nodeById.forEach(n => {
              if (!n.parent) return;
              const p = nodeById.get(n.parent);
              const should = p && p.visible && p.expanded;
              if (should && !n.visible) {
                n.visible = true;
                changed = true;
              }
            });
          }
        }

        // ä¾ label é•·åº¦ & å±¤ç´šåšåœ“è§’çŸ©å½¢å°ºå¯¸
        function getRectSize(n) {
          const len = n.label.length;
          let baseW, baseH, perChar;
          if (n.level === 1) {
            baseW = 180; baseH = 60; perChar = 5;
          } else if (n.level === 2) {
            baseW = 170; baseH = 50; perChar = 4.5;
          } else {
            baseW = 160; baseH = 44; perChar = 4;
          }
          const width = Math.max(baseW, 40 + len * perChar);
          const height = baseH;
          return { width, height };
        }

        // å­ç¯€é»é †æ™‚é‡ç’°ç¹æ¯ç¯€é»
        function placeChildrenClockwise(parent, children) {
          if (!children || children.length === 0) return;
          const step = (2 * Math.PI) / children.length;
          const radius = parent.level === 1 ? 260 : 210;

          children.forEach((c, i) => {
            const angle = 0 - i * step; // å¾å³å´é–‹å§‹é †æ™‚é‡
            c.fx = parent.x + Math.cos(angle) * radius;
            c.fy = parent.y + Math.sin(angle) * radius;
          });
        }

        function buildGraphData() {
          computeVisibility();

          // æ¸…æ‰ fx/fy é¿å…ä¹‹å‰å±•é–‹æ®˜ç•™
          nodeById.forEach(n => {
            n.fx = null;
            n.fy = null;
          });

          const newNodes = [];
          const newLinks = [];

          nodeById.forEach(n => {
            if (n.visible) newNodes.push(n);
          });
          nodeById.forEach(n => {
            if (!n.visible || !n.parent) return;
            const p = nodeById.get(n.parent);
            if (p && p.visible) {
              newLinks.push({ source: p, target: n });
            }
          });

          // ä¾æ¯ç¯€é»è¨­å®šå­ç¯€é» fx/fy
          newNodes.forEach(n => {
            if (n.expanded && n.children && n.children.length > 0) {
              const kids = n.children.filter(c => c.visible);
              placeChildrenClockwise(n, kids);
            }
          });

          return { nodes: newNodes, links: newLinks };
        }

        ({ nodes, links } = buildGraphData());

        // Force simulation
        const simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links)
            .id(d => d.id)
            .distance(160)
            .strength(0.3))
          .force("charge", d3.forceManyBody().strength(-400))
          .force("collide", d3.forceCollide().radius(d => getRectSize(d).width / 2 + 20))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .alphaTarget(0.15)
          .on("tick", ticked);

        let linkSel = viewport.append("g")
          .attr("class", "edges")
          .selectAll("line");

        let nodeSel = viewport.append("g")
          .attr("class", "nodes")
          .selectAll("g");

        function updateGraph() {
          ({ nodes, links } = buildGraphData());

          simulation.nodes(nodes);
          simulation.force("link").links(links);
          simulation.alpha(0.5).restart(); // å‹•ç•«å•Ÿå‹•ï¼Œä½†è¼ƒç‚ºå¹³é †

          // edges
          linkSel = linkSel.data(links, d => d.source.id + "-" + d.target.id);
          linkSel.exit().remove();
          linkSel = linkSel.enter()
            .append("line")
            .attr("class", "rugatha-edge")
            .merge(linkSel);

          // nodes
          nodeSel = nodeSel.data(nodes, d => d.id);
          nodeSel.exit().remove();

          const enter = nodeSel.enter()
            .append("g")
            .attr("class", d => "level-" + d.level)
            .call(
              d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)
            );

          // Root ç”¨ iconï¼Œå…¶é¤˜ç”¨åœ“è§’çŸ©å½¢
          enter.each(function (d) {
            const g = d3.select(this);
            if (d.level === 1) {
              const size = 90;
              g.append("image")
                .attr("href", ROOT_ICON_URL)
                .attr("width", size)
                .attr("height", size)
                .attr("x", -size / 2)
                .attr("y", -size / 2);
            } else {
              const r = getRectSize(d);
              g.append("rect")
                .attr("class", "node-rect")
                .attr("x", -r.width / 2)
                .attr("y", -r.height / 2)
                .attr("width", r.width)
                .attr("height", r.height)
                .attr("rx", 18)
                .attr("ry", 18);
            }
          });

          // æ–‡å­—ï¼ˆroot ä¸é¡¯ç¤ºæ–‡å­—ï¼‰
          enter.append("text")
            .attr("class", "node-label")
            .text(d => (d.level === 1 ? "" : d.label));

          // é»ç¯€é»ï¼šç´€éŒ„ pendingCenterï¼Œå±•é–‹ / æ”¶åˆå¾Œåœ¨ tick ä¸­ç½®ä¸­
          enter.on("click", (event, d) => {
            event.stopPropagation();
            pendingCenter = d; // äº¤çµ¦ tick æ™‚è™•ç†ç½®ä¸­

            if (d.children && d.children.length > 0) {
              d.expanded = !d.expanded;
              updateGraph();
            }
          });

          nodeSel = enter.merge(nodeSel);
        }

        function ticked() {
          linkSel
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

          nodeSel.attr("transform", d => `translate(${d.x},${d.y})`);

          // è‹¥æœ‰ pendingCenterï¼Œåœ¨ç¬¬ä¸€å€‹ tick åŸ·è¡Œç½®ä¸­ï¼Œé¿å…äº‚è·³
          if (pendingCenter) {
            centerOnNode(pendingCenter, 350);
            pendingCenter = null;
          }
        }

        function dragstarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.15).restart();
          d.fx = d.x;
          d.fy = d.y;
        }

        function dragged(event, d) {
          d.fx = event.x;
          d.fy = event.y;
        }

        function dragended(event, d) {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        }

        // Zoom / pan
        const zoom = d3.zoom()
          .scaleExtent([0.3, 3])
          .on("zoom", (event) => {
            currentTransform = event.transform; // æ›´æ–°ç›®å‰ transform
            viewport.attr("transform", event.transform);
          });

        svg.call(zoom);

        // ç½®ä¸­æŸç¯€é»ï¼ˆå‹•ç•«æ™‚é–“å¯èª¿ï¼‰
        function centerOnNode(node, duration) {
          const d = duration || 350;
          const t = d3.zoomIdentity
            .translate(width / 2 - node.x, height / 2 - node.y)
            .scale(1);

          svg.transition()
            .duration(d)
            .call(zoom.transform, t);
        }

        // Fit-to-viewï¼šè®“ç›®å‰æ‰€æœ‰å¯è¦‹ç¯€é»éƒ½åœ¨ç•«é¢å…§
        function fitToView() {
          if (!nodes || nodes.length === 0) return;

          let minX = Infinity, maxX = -Infinity;
          let minY = Infinity, maxY = -Infinity;

          nodes.forEach(n => {
            if (!isFinite(n.x) || !isFinite(n.y)) return;
            if (n.x < minX) minX = n.x;
            if (n.x > maxX) maxX = n.x;
            if (n.y < minY) minY = n.y;
            if (n.y > maxY) maxY = n.y;
          });

          if (!isFinite(minX) || !isFinite(minY)) return;

          const padding = 40;
          const w = maxX - minX || 1;
          const h = maxY - minY || 1;

          const scale = Math.max(
            0.3,
            Math.min(
              3,
              0.9 * Math.min(width / (w + padding * 2), height / (h + padding * 2))
            )
          );

          const cx = (minX + maxX) / 2;
          const cy = (minY + maxY) / 2;

          const tx = width / 2 - cx * scale;
          const ty = height / 2 - cy * scale;

          const t = d3.zoomIdentity.translate(tx, ty).scale(scale);

          svg.transition().duration(350).call(zoom.transform, t);
        }

        // ä»¥ç›®å‰ä¸­å¿ƒç‚ºåŸºæº–æ”¾å¤§ / ç¸®å°
        function zoomByFactor(factor) {
          const t = currentTransform;
          const cx = width / 2;
          const cy = height / 2;

          const newK = Math.max(0.3, Math.min(3, t.k * factor));
          const scaleFactor = newK / t.k;

          const newX = cx - (cx - t.x) * scaleFactor;
          const newY = cy - (cy - t.y) * scaleFactor;

          const newTransform = d3.zoomIdentity.translate(newX, newY).scale(newK);

          svg.transition()
            .duration(200)
            .call(zoom.transform, newTransform);
        }

        // é»èƒŒæ™¯é‡ç½®è¦–è§’
        svg.on("click", () => {
          const t = d3.zoomIdentity.translate(width / 2, height / 2).scale(1);
          svg.transition().duration(350).call(zoom.transform, t);
        });

        // ç¶å®šæŒ‰éˆ•äº‹ä»¶
        document.getElementById("btn-zoom-in").addEventListener("click", (e) => {
          e.stopPropagation();
          zoomByFactor(1.2);
        });

        document.getElementById("btn-zoom-out").addEventListener("click", (e) => {
          e.stopPropagation();
          zoomByFactor(1 / 1.2);
        });

        document.getElementById("btn-fit").addEventListener("click", (e) => {
          e.stopPropagation();
          fitToView();
        });

        document.getElementById("btn-home").addEventListener("click", (e) => {
          e.stopPropagation();
          const t = d3.zoomIdentity;
          svg.transition().duration(350).call(zoom.transform, t);
        });

        // åˆå§‹ render
        updateGraph();
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
