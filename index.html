<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rugatha Campaign Graph (Neo4j-like)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body {
      margin: 0;
      background: #0b0d11;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    h1 {
      text-align: center;
      margin: 16px 0 8px;
      font-size: 20px;
      font-weight: 600;
      color: #f9fafb;
    }

    #rugatha-graph-plugin {
      width: 100%;
      height: calc(100vh - 60px);
      max-height: 700px;
      box-sizing: border-box;
    }

    #rugatha-graph-svg {
      width: 100%;
      height: 100%;
      background: #05070a; /* 深色底，有 Neo4j 味道 */
      cursor: grab;
      user-select: none;
    }

    #rugatha-graph-svg.rugatha-panning {
      cursor: grabbing;
    }

    /* ===== 線條（關聯邊） ===== */
    .rugatha-edge {
      stroke: #374151;
      stroke-width: 1.2;
      stroke-opacity: 0.8;
    }

    /* ===== 節點的圓角矩形樣式（寬高由 JS 控制） ===== */
    .node-rect {
      stroke: #111827;
      stroke-width: 1.4;
    }

    .level-2 .node-rect {
      fill: #3b82f6; /* 第二層: 藍色 */
    }

    .level-3 .node-rect {
      fill: #9ca3af; /* 第三層: 灰色 */
    }

    /* Level 1 用圖片，不使用 rect，因此不在這裡設 fill */

    /* ===== 節點文字 ===== */
    .node-label {
      fill: #f9fafb;
      pointer-events: none;
      text-anchor: middle;
      dominant-baseline: central;
    }

    .level-1 .node-label {
      font-size: 14px;
      font-weight: 800;
    }

    .level-2 .node-label {
      font-size: 12px;
      font-weight: 700;
    }

    .level-3 .node-label {
      font-size: 10px;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <h1>Rugatha Campaign Graph</h1>

  <div id="rugatha-graph-plugin">
    <svg id="rugatha-graph-svg"></svg>
  </div>

  <!-- 1) 階層資料 -->
  <script src="graph-data.js"></script>

  <!-- 2) D3.js -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- 3) 主程式：Force-directed + 圓角矩形 + root icon -->
  <script>
    (function () {
      const ROOT_ICON_URL =
        "https://rugatha.wordpress.com/wp-content/uploads/2025/05/cropped-e69caae591bde5908d-1_e5b7a5e4bd9ce58d80e59f9f-1-1.png";

      const rawData = (window.CAMPAIGN_GRAPH_DATA || []);

      function init() {
        const svg = d3.select("#rugatha-graph-svg");
        if (svg.empty()) return;

        const width = svg.node().clientWidth;
        const height = svg.node().clientHeight;

        // zoom / pan group
        const viewport = svg.append("g").attr("id", "rugatha-graph-viewport");

        // 建立節點 map
        const nodeById = new Map();
        rawData.forEach(d => {
          nodeById.set(d.id, {
            id: d.id,
            label: d.label,
            level: d.level,
            parent: d.parent,
            children: [],
            expanded: d.level === 1, // root 預設展開
            visible: false,
            x: width / 2,
            y: height / 2
          });
        });

        // parent -> children
        nodeById.forEach(node => {
          if (node.parent) {
            const p = nodeById.get(node.parent);
            if (p) p.children.push(node);
          }
        });

        // 根據 expanded 狀態計算可見性
        function computeVisibility() {
          nodeById.forEach(n => (n.visible = false));

          // 沒有 parent 的當 root，先設為可見
          nodeById.forEach(node => {
            if (!node.parent) {
              node.visible = true;
            }
          });

          // BFS 往下展開
          let changed = true;
          while (changed) {
            changed = false;
            nodeById.forEach(node => {
              if (!node.parent) return;
              const parent = nodeById.get(node.parent);
              const shouldBeVisible =
                parent && parent.visible && parent.expanded;
              if (shouldBeVisible && !node.visible) {
                node.visible = true;
                changed = true;
              }
            });
          }
        }

        // 依據 label 長度 & level 來決定圓角矩形大小，避免文字 overflow
        function getRectSize(node) {
          const textLen = node.label.length;
          // 基礎寬度和高度依層級遞增，呈現階層感
          let baseW, baseH, perChar;
          if (node.level === 1) {
            baseW = 180;
            baseH = 60;
            perChar = 5.0;
          } else if (node.level === 2) {
            baseW = 170;
            baseH = 50;
            perChar = 4.5;
          } else {
            baseW = 160;
            baseH = 44;
            perChar = 4.0;
          }
          const w = Math.max(baseW, 40 + textLen * perChar);
          const h = baseH;
          return { width: w, height: h };
        }

        function buildGraphData() {
          computeVisibility();

          const nodes = [];
          const links = [];

          nodeById.forEach(node => {
            if (node.visible) nodes.push(node);
          });

          nodeById.forEach(node => {
            if (!node.visible || !node.parent) return;
            const parent = nodeById.get(node.parent);
            if (parent && parent.visible) {
              links.push({ source: parent, target: node });
            }
          });

          return { nodes, links };
        }

        let { nodes, links } = buildGraphData();

        /* ---- D3 force simulation ---- */
        const simulation = d3
          .forceSimulation(nodes)
          .force(
            "link",
            d3
              .forceLink(links)
              .id(d => d.id)
              .distance(160)
              .strength(0.9)
          )
          .force(
            "charge",
            d3.forceManyBody().strength(-500)
          )
          .force(
            "center",
            d3.forceCenter(width / 2, height / 2)
          )
          .force("collision", d3.forceCollide().radius(d => {
            const size = getRectSize(d);
            // 半寬 + 邊距，避免矩形重疊
            return size.width / 2 + 15;
          }));

        // edges & nodes selection
        let linkSel = viewport
          .append("g")
          .attr("class", "edges")
          .selectAll("line");

        let nodeSel = viewport
          .append("g")
          .attr("class", "nodes")
          .selectAll("g");

        function updateGraph() {
          ({ nodes, links } = buildGraphData());

          simulation.nodes(nodes);
          simulation.force("link").links(links);

          // edges
          linkSel = linkSel
            .data(links, d => d.source.id + "-" + d.target.id);

          linkSel.exit().remove();

          const linkEnter = linkSel
            .enter()
            .append("line")
            .attr("class", "rugatha-edge");

          linkSel = linkEnter.merge(linkSel);

          // nodes
          nodeSel = nodeSel.data(nodes, d => d.id);
          nodeSel.exit().remove();

          const nodeEnter = nodeSel
            .enter()
            .append("g")
            .attr("class", d => "rugatha-node level-" + d.level)
            .call(
              d3
                .drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)
            );

          // Level 1 用 icon，Level 2/3 用圓角矩形
          nodeEnter.each(function (d) {
            const g = d3.select(this);

            if (d.level === 1) {
              const size = 90; // icon 大小，可視需要微調
              g.append("image")
                .attr("href", ROOT_ICON_URL)
                .attr("width", size)
                .attr("height", size)
                .attr("x", -size / 2)
                .attr("y", -size / 2);
            } else {
              const rectSize = getRectSize(d);
              g.append("rect")
                .attr("class", "node-rect")
                .attr("x", -rectSize.width / 2)
                .attr("y", -rectSize.height / 2)
                .attr("width", rectSize.width)
                .attr("height", rectSize.height)
                .attr("rx", 18)  // 圓角半徑
                .attr("ry", 18);
            }
          });

          // 文字（Level 1 用 icon，不另外顯示文字）
          nodeEnter
            .append("text")
            .attr("class", "node-label")
            .text(d => (d.level === 1 ? "" : d.label));

          // 點節點：展開 / 收合 + 置中
          nodeEnter.on("click", (event, d) => {
            event.stopPropagation();
            if (d.children && d.children.length > 0) {
              d.expanded = !d.expanded;
              updateGraph();
            }
            centerOnNode(d);
          });

          nodeSel = nodeEnter.merge(nodeSel);

          simulation.alpha(1).restart();
        }

        simulation.on("tick", () => {
          linkSel
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

          nodeSel.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // drag 行為
        function dragstarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }

        function dragged(event, d) {
          d.fx = event.x;
          d.fy = event.y;
        }

        function dragended(event, d) {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = event.x;
          d.fy = event.y;
        }

        // zoom / pan
        const zoom = d3.zoom()
          .scaleExtent([0.3, 3])
          .on("zoom", (event) => {
            viewport.attr("transform", event.transform);
          });

        svg.call(zoom);

        // 置中特定節點
        function centerOnNode(node) {
          const t = d3.zoomIdentity
            .translate(width / 2 - node.x, height / 2 - node.y)
            .scale(1);

          svg.transition()
            .duration(400)
            .call(zoom.transform, t);
        }

        // 點背景：重置視圖
        svg.on("click", () => {
          const t = d3.zoomIdentity
            .translate(width / 2, height / 2)
            .scale(1);
          svg.transition().duration(400).call(zoom.transform, t);
        });

        // 初始 render
        updateGraph();
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
